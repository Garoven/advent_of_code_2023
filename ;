use itertools::Itertools;

enum Dir {
    Up,
    Down,
    Left,
    Right,
}

fn beam(map: &[&str], mut pos: (usize, usize), dir: Dir, titles: &mut Vec<(usize, usize)>) {
    match dir {
        Dir::Up if pos.0 != 0 => pos.0 -= 1,
        Dir::Down if pos.0 < map.len() => pos.0 += 1,
        Dir::Left if pos.1 != 0 => pos.1 -=1,
        Dir::Right if pos.1 != map[0].len() => pos.1 += 1
    }
    match &map[pos.0][pos.1..=pos.1] {}
}

pub fn part_1<T: AsRef<str>>(input: T) -> u64 {
    let mut titles: Vec<(usize, usize)> = vec![(0, 0)];
    let map = input.as_ref().lines().collect_vec();

    beam(&map, (0, 0), Dir::Left, &mut titles);

    0
}

pub fn part_2<T: AsRef<str>>(input: T) -> u64 {
    0
}

#[cfg(test)]
mod tests {
    use super::*;

    const INPUT: &str = include_str!("./test.txt");

    #[test]
    fn part_1_ok() {
        let result = part_1(INPUT);
        let expected = 46;

        assert_eq!(expected, result);
    }

    #[test]
    fn part_2_ok() {
        let result = part_2(INPUT);
        let expected = 145;

        assert_eq!(expected, result);
    }
}
